[{"title":"Git工具.gitmodules","url":"/blog/2021/03/09/Git%E5%B7%A5%E5%85%B7-.gitmodules/","content":"\n我们在项目目录中有时可能会见到这种文件.gitmodules这个文件的应用场景：某个工作中的项目需要包含并使用另一个项目，但又想两个项目同时独立\n\n如何将一个项目作为另一个项目的子模块提交上去呢？git submodule add 子模块的url\n默认情况下 ，子模块会将子项目放到一个与仓库同名的目录中\n克隆含有子模块的项目按照正常的拉取代码的形式， 拉取下来的项目默认会包含子模块目录，但是目录内容为空两种方式：\n\n运行两个命令：git submodule init 用来初始化本地配置文件git submodule update 从该项目中抓取所有数据并检出父项目中列出的合适的提交\ngit clone命令传递–recurse-submodules 选项，它就会自动初始化并更新仓库中的每一个子模块，包括可能存在的嵌套子模块\n\n如果已经克隆了项目，但是忘记了–recurse-submodules，那么可以运行git submodule update –init将以上两个命令合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块，可以使用git submodule update –init –recursive\n在包含子模块的项目上工作更新子模块：git submodule update –remote 子模块名字加上子模块的名字可以更新固定的模块\n推送可以让Git在推送到主项目前检查所有子模块是否已推送git push –recurse-submodules=check如果任何提交的子模块改动没有推送那么“check“选项会直接使push操作失败失败之后如何做？进入到每一个子模块中然后手动推送到远程仓库，之后再次尝试这次推送\n","tags":["开发工具"]},{"title":"myFirstBlog","url":"/blog/2021/01/20/myFirstBlog/","content":"","categories":["have a try"],"tags":["Movie","Travel"]},{"title":"虚拟机&容器对比","url":"/blog/2021/01/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E5%8C%BA%E5%88%AB/","content":"虚拟机和容器的对比图\n图左—虚拟机的原理Hypervisor：虚拟机监控器，是一个用于创建和运行虚拟机的进程\n一台主机计算机可通过虚拟化的方式共享其资源(如内存和处理资源)来支持多台客户机虚拟机，它在这些虚拟的硬件上安装了一个新的操作系统，即Guest OS\n用户进程可以运行在这个虚拟的机器中 ，它能看到的自然也只有Guest OS的文件和目录，以及这个机器里的虚拟设备\n图右—容器原理用户运行在容器里的应用进程，跟宿主机上的其他进程一样，都由宿主机操作系统统一管理，只不过这些被隔离的进程拥有额外设置过的Namespace参数，而Docker Engine在这里扮演的角色，更多是旁路式的辅助和管理工作\n为什么Docker项目比虚拟机更受欢迎\n使用虚拟化技术作为应用沙盒，就必须要由Hypervisor来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行着一个完整的Guest OS才能执行用户的应用进程，这就不可避免地带来了额外的资源消耗和占用\n\n用户应用运行在虚拟机里面，它对宿主机操作系统的调用就不可避免地要经过虚拟化软件的拦截和处理，这本身就是一层性能消耗，尤其是计算资源、网络和磁盘I/O的损耗非常大\n\n相比之下，容器化后的用户应用，却依然还是一个宿主机的普通进程，这就意味着因为虚拟化而带来的性能损耗都是不存在的此外，使用Namespace作为隔离手段的容器不需要单独的Guest OS，这就使得容器额外的资源占用几乎可以忽略不计\n\n但Docker也存在不足之处-隔离得不彻底，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统的内核；其次，在Linux内核中 ，有很多资源和对象是不能被Namesapce化的，比如时间\n\n\n","tags":["容器系列"]}]